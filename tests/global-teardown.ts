/**
 * Vitest global teardown — sweep any leaked test tasks from the live server.
 *
 * Live-server tests (reflection-origin-gate, artifact-visibility, pipeline-health-merge)
 * tag tasks with `metadata.is_test = true` and clean up in their own afterAll.
 * But if vitest crashes, times out, or is killed, afterAll never fires.
 *
 * This global teardown runs once after ALL test files finish (or vitest exits)
 * and deletes every task that:
 *   1. Has metadata.is_test === true, OR
 *   2. Was created during this test run AND matches known test-task title patterns
 *
 * Belt-and-suspenders to prevent test pollution of the live task board.
 */

const BASE = 'http://127.0.0.1:4445'

/** Known title patterns generated by live-server tests */
const TEST_TITLE_PATTERNS = [
  /^Enforce reflection-origin invariant on task creation pipeline \d+$/,
  /^Accept task from reflection pipeline source with full metadata \d+$/,
  /^Accept task with source insight in metadata for pipeline validation \d+$/,
  /^System maintenance task exempt from reflection origin requirement \d+$/,
  /^Implement artifact visibility endpoint with heartbeat validation for test run \d+$/,
  /^\[Insight\].*Pipeline health check reports broken/,
]

let testRunStart: number

export async function setup(): Promise<void> {
  testRunStart = Date.now()
}

export async function teardown(): Promise<void> {
  let serverUp = false
  try {
    const res = await fetch(`${BASE}/health`, { signal: AbortSignal.timeout(2000) })
    serverUp = res.ok
  } catch {
    return
  }
  if (!serverUp) return

  try {
    const res = await fetch(`${BASE}/tasks?limit=500`)
    if (!res.ok) return
    const data = (await res.json()) as any
    const tasks: any[] = data.tasks || []

    const toDelete = tasks.filter((t: any) => {
      // Criterion 1: explicitly marked as test
      if (t.metadata?.is_test === true) return true

      // Criterion 2: created during this test run + matches known test pattern
      const createdAt = t.createdAt || 0
      if (createdAt >= testRunStart && typeof t.title === 'string') {
        return TEST_TITLE_PATTERNS.some(p => p.test(t.title))
      }

      return false
    })

    if (toDelete.length === 0) return

    console.log(`[Global Teardown] Cleaning ${toDelete.length} leaked test task(s)...`)
    for (const t of toDelete) {
      try {
        await fetch(`${BASE}/tasks/${t.id}`, { method: 'DELETE' })
      } catch { /* best-effort */ }
    }
    console.log(`[Global Teardown] Done.`)
  } catch {
    // Best-effort — don't fail the test run for cleanup issues
  }
}
